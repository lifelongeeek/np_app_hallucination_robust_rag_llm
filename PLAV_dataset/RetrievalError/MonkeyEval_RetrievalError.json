{
	"PandasEval/0": {
		"query": "You can specify a new column named `average_along_rows` that contains the average of each row. You also need to compute the average along the rows, so use axis=1. Finally, return the knowledgeframe with the new column.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_4": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/1": {
		"query": "How do I select rows from a KnowledgeFrame kf based on column values? Return rows whose column value named `col_name` is in an iterable `values`",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_4": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_5": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/2": {
		"query": "How do I change the column labels of kf\uff1f And return the knowledgeframe that has been renamed",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/3": {
		"query": "deleting a column from a Monkey KnowledgeFrame return the changged knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/4": {
		"query": "How do I select the given columns and return the new KnowledgeFrame?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "ifnull(self) -> 'np.ndarray':\n        Detect missing values.\n\n        Return a boolean same-sized object indicating if the values are NA.\n        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`mk.NaT`, getting\n        mappingped to ``True`` values.\n        Everything else getting mappingped to ``False`` values. Characters such as\n        empty strings `''` or :attr:`numpy.inf` are not considered NA values\n        (unless you set ``monkey.options.mode.use_inf_as_na = True``).\n\n        Returns\n        -------\n        numpy.ndarray[bool]\n            A boolean array of whether my values are NA.\n\n        See Also\n        --------\n        Index.notna : Boolean inverse of ifna.\n        Index.sipna : Omit entries with missing values.\n        ifna : Top-level ifna.\n        Collections.ifna : Detect missing values in Collections object.\n\n        Examples\n        --------\n        Show which entries in a monkey.Index are NA. The result is an\n        array.\n\n        >>> idx = mk.Index([5.2, 6.0, np.NaN])\n        >>> idx\n        Float64Index([5.2, 6.0, nan], dtype='float64')\n        >>> idx.ifna()\n        array([False, False,  True])\n\n        Empty strings are not considered NA values. None is considered an NA\n        value.\n\n        >>> idx = mk.Index(['black', '', 'red', None])\n        >>> idx\n        Index(['black', '', 'red', None], dtype='object')\n        >>> idx.ifna()\n        array([False, False, False,  True])\n\n        For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n        >>> idx = mk.DatetimeIndex([mk.Timestamp('1940-04-25'),\n        ...                         mk.Timestamp(''), None, mk.NaT])\n        >>> idx\n        DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                      dtype='datetime64[ns]', freq=None)\n        >>> idx.ifna()\n        array([False,  True,  True,  True])\n        ",
			"API_5": "ifna(self) -> 'np.ndarray':\n        Detect missing values.\n\n        Return a boolean same-sized object indicating if the values are NA.\n        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`mk.NaT`, getting\n        mappingped to ``True`` values.\n        Everything else getting mappingped to ``False`` values. Characters such as\n        empty strings `''` or :attr:`numpy.inf` are not considered NA values\n        (unless you set ``monkey.options.mode.use_inf_as_na = True``).\n\n        Returns\n        -------\n        numpy.ndarray[bool]\n            A boolean array of whether my values are NA.\n\n        See Also\n        --------\n        Index.notna : Boolean inverse of ifna.\n        Index.sipna : Omit entries with missing values.\n        ifna : Top-level ifna.\n        Collections.ifna : Detect missing values in Collections object.\n\n        Examples\n        --------\n        Show which entries in a monkey.Index are NA. The result is an\n        array.\n\n        >>> idx = mk.Index([5.2, 6.0, np.NaN])\n        >>> idx\n        Float64Index([5.2, 6.0, nan], dtype='float64')\n        >>> idx.ifna()\n        array([False, False,  True])\n\n        Empty strings are not considered NA values. None is considered an NA\n        value.\n\n        >>> idx = mk.Index(['black', '', 'red', None])\n        >>> idx\n        Index(['black', '', 'red', None], dtype='object')\n        >>> idx.ifna()\n        array([False, False, False,  True])\n\n        For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n        >>> idx = mk.DatetimeIndex([mk.Timestamp('1940-04-25'),\n        ...                         mk.Timestamp(''), None, mk.NaT])\n        >>> idx\n        DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                      dtype='datetime64[ns]', freq=None)\n        >>> idx.ifna()\n        array([False,  True,  True,  True])\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/5": {
		"query": "Return the row count of kf",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/6": {
		"query": "I want to get a list of the column headers from a Monkey KnowledgeFrame. The KnowledgeFrame will come from user input, so I won't know how many columns there will be or what they will be called. Return a list of the column headers.",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/7": {
		"query": "How to add a new column to an existing KnowledgeFrame? I would like to add a new column data with the column name, to the existing knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_3": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        ",
			"API_4": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_5": "length(self):\n        Compute the lengthgth of each element in the Collections/Index.\n\n        The element may be a sequence (such as a string, tuple or list) or a collection\n        (such as a dictionary).\n\n        Returns\n        -------\n        Collections or Index of int\n            A Collections or Index of integer values indicating the lengthgth of each\n            element in the Collections or Index.\n\n        See Also\n        --------\n        str.length : Python built-in function returning the lengthgth of an object.\n        Collections.size : Returns the lengthgth of the Collections.\n\n        Examples\n        --------\n        Returns the lengthgth (number of characters) in a string. Returns the\n        number of entries for dictionaries, lists or tuples.\n\n        >>> s = mk.Collections(['dog',\n        ...                 '',\n        ...                 5,\n        ...                 {'foo' : 'bar'},\n        ...                 [2, 3, 5, 7],\n        ...                 ('one', 'two', 'three')])\n        >>> s\n        0                  dog\n        1\n        2                    5\n        3       {'foo': 'bar'}\n        4         [2, 3, 5, 7]\n        5    (one, two, three)\n        dtype: object\n        >>> s.str.length()\n        0    3.0\n        1    0.0\n        2    NaN\n        3    1.0\n        4    4.0\n        5    3.0\n        dtype: float64\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/8": {
		"query": "Change all columns type of KnowledgeFrame to numeric And return the new KnowledgeFrame The code is:",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_3": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_4": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_5": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/9": {
		"query": "How to sip rows of Monkey KnowledgeFrame whose value in a certain column is NaN",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "interst(self, other, sort=False):\n        Form the interst of two Index objects.\n\n        This returns a new Index with elements common to the index and `other`.\n\n        Parameters\n        ----------\n        other : Index or array-like\n        sort : False or None, default False\n            Whether to sort the resulting index.\n\n            * False : do not sort the result.\n            * None : sort the result, except when `self` and `other` are equal\n              or when the values cannot be compared.\n\n        Returns\n        -------\n        interst : Index\n\n        Examples\n        --------\n        >>> idx1 = mk.Index([1, 2, 3, 4])\n        >>> idx2 = mk.Index([3, 4, 5, 6])\n        >>> idx1.interst(idx2)\n        Int64Index([3, 4], dtype='int64')\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/11": {
		"query": "Params: kf: The knowledgeframe to add to. list_to_add: The list to add. column_name_list: The column names of the list to add. Returns: The knowledgeframe with the list added.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "interst(self, other, sort=False):\n        Form the interst of two Index objects.\n\n        This returns a new Index with elements common to the index and `other`.\n\n        Parameters\n        ----------\n        other : Index or array-like\n        sort : False or None, default False\n            Whether to sort the resulting index.\n\n            * False : do not sort the result.\n            * None : sort the result, except when `self` and `other` are equal\n              or when the values cannot be compared.\n\n        Returns\n        -------\n        interst : Index\n\n        Examples\n        --------\n        >>> idx1 = mk.Index([1, 2, 3, 4])\n        >>> idx2 = mk.Index([3, 4, 5, 6])\n        >>> idx1.interst(idx2)\n        Int64Index([3, 4], dtype='int64')\n        ",
			"API_5": "average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs):\nReturn the average of the values over the requested axis.\n\nParameters\n----------\naxis : {index (0)}\n    Axis for the function to be applied on.\nskipna : bool, default True\n    Exclude NA/null values when computing the result.\nlevel : int or level name, default None\n    If the axis is a MultiIndex (hierarchical), count along a\n    particular level, collapsing into a scalar.\nnumeric_only : bool, default None\n    Include only float, int, boolean columns. If None, will attempt to use\n    everything, then use only numeric data. Not implemented for Collections.\n**kwargs\n    Additional keyword arguments to be passed to the function.\n\nReturns\n-------\nscalar or Collections (if level specified)\n"
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/12": {
		"query": "I am trying to extract the last year (YY) of a fiscal date string in the format of YYYY-YY. e.g The last year of this '1999-00' would be 2000. I need a logic to include a case where if it is the end of the century then my employ method should add to the first two digits. the column_name is the column name of the knowledgeframe that contains the date strings. return the numerical Collections obj of the last year.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/13": {
		"query": "How to get the last N rows of a monkey KnowledgeFrame?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/14": {
		"query": "how do I get the value at an nth row of a given column name in Monkey? return the value",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/15": {
		"query": "creating a new knowledgeframe of all same with kf_original one, but no any rows return the new knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/20": {
		"query": "What is the best way to do a grouper on a Monkey knowledgeframe, but exclude some columns from that grouper? I want to grouper the column `Country` and `Item_Code` and only compute the sum of the rows falling under the columns ['Y1961', 'Y1962' and 'Y1963'].",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/10": {
		"query": "creating a Collections from a list [56, 24, 421, 90]",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_3": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/16": {
		"query": "What I want is to clip the values of `col_1` between -2 to 2 if `col_0` is `a`. Using `clip` function in monkey.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/17": {
		"query": "I would like to create new knowledgeframe out of the old one in a way that there will only be values that exceed the average value of the column. We can compare values and then add NaNs by indexing or `where` We want remove NaNs also in first rows add custom function with `sipna`",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/18": {
		"query": "Appending the source collections to the target collections, with ignoring the index or resetting index",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame':\n        Apply a function to a Dataframe elementwise.\n\n        This method applies a function that accepts and returns a scalar\n        to every element of a KnowledgeFrame.\n\n        Parameters\n        ----------\n        func : ctotal_allable\n            Python function, returns a single value from a single value.\n        na_action : {None, 'ignore'}, default None\n            If \u2018ignore\u2019, propagate NaN values, without passing them to func.\n\n            .. versionadded:: 1.2\n\n        **kwargs\n            Additional keyword arguments to pass as keywords arguments to\n            `func`.\n\n            .. versionadded:: 1.3.0\n\n        Returns\n        -------\n        KnowledgeFrame\n            Transformed KnowledgeFrame.\n\n        See Also\n        --------\n        KnowledgeFrame.employ : Apply a function along input axis of KnowledgeFrame.\n\n        Examples\n        --------\n        >>> kf = mk.KnowledgeFrame([[1, 2.12], [3.356, 4.567]])\n        >>> kf\n               0      1\n        0  1.000  2.120\n        1  3.356  4.567\n\n        >>> kf.employmapping(lambda x: length(str(x)))\n           0  1\n        0  3  4\n        1  5  5\n\n        Like Collections.mapping, NA values can be ignored:\n\n        >>> kf_clone = kf.clone()\n        >>> kf_clone.iloc[0, 0] = mk.NA\n        >>> kf_clone.employmapping(lambda x: length(str(x)), na_action='ignore')\n              0  1\n        0  <NA>  4\n        1     5  5\n\n        Note that a vectorized version of `func` often exists, which will\n        be much faster. You could square each number elementwise.\n\n        >>> kf.employmapping(lambda x: x**2)\n                   0          1\n        0   1.000000   4.494400\n        1  11.262736  20.857489\n\n        But it's better to avoid employmapping in that case.\n\n        >>> kf ** 2\n                   0          1\n        0   1.000000   4.494400\n        1  11.262736  20.857489\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/19": {
		"query": "Selecting rows where column x2 is NaN",
		"retrieved_APIs": {
			"API_1": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        ",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/21": {
		"query": "I want to convert a table, represented as a list of lists, into a monkey KnowledgeFrame. The columns are ['one', 'two'] What is the best way to convert the columns to the appropriate types, in this case the 'two' column into floats?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/22": {
		"query": "I need to change the dtype of multiple columns but the knowledgeframe has different kind of dtypes. Some columns dtypes are float64 whereas some columns are int64 I need to change all float64 to float32.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/23": {
		"query": "I have a knowledgeframe that has two columns, the second column is one of only a few values. I want to return a knowledgeframe where only the rows where that col2 had a specific value 'Jimmy' are included.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_5": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/24": {
		"query": "kf = kf.reseting_index() make sure indexes pair with number of rows (for index, row in KnowledgeFrame.traversal) is a generator which yields both the index and row (as a Collections) for each row in the KnowledgeFrame, we need put the row['MSRA'] (as key) and row['THU'] (as value) into a rows_dict rows_dict = {} {MSRA: THU, ...}",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/25": {
		"query": "I have a knowledgeframe in monkey where each column has different value range. Any idea how I can normalize the columns of this knowledgeframe where each value is between 0 and 1?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/26": {
		"query": "I want to create a knowledgeframe with one of the column as a list or array. After you assign a list like or array like value to the columns, the column should be considered as type object Now I want to assign the emails to first row and the 'Email' column",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/28": {
		"query": "In my code, I have several variables which can either contain a monkey KnowledgeFrame or nothing at all. Let's say I want to test and see if a certain KnowledgeFrame has been created yet or not.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT':\n        Return distinctive values in the index.\n\n        Unique values are returned in order of appearance, this does NOT sort.\n\n        Parameters\n        ----------\n        level : int or hashable, optional\n            Only return values from specified level (for MultiIndex).\n            If int, gettings the level by integer position, else by level name.\n\n        Returns\n        -------\n        Index\n\n        See Also\n        --------\n        distinctive : Numpy array of distinctive values in that column.\n        Collections.distinctive : Return distinctive values of Collections object.\n        ",
			"API_5": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/29": {
		"query": "I need to remain the rows where line_num is not equal to 0. What's the most efficient way to do it? it should be as simple as:",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_3": "distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT':\n        Return distinctive values in the index.\n\n        Unique values are returned in order of appearance, this does NOT sort.\n\n        Parameters\n        ----------\n        level : int or hashable, optional\n            Only return values from specified level (for MultiIndex).\n            If int, gettings the level by integer position, else by level name.\n\n        Returns\n        -------\n        Index\n\n        See Also\n        --------\n        distinctive : Numpy array of distinctive values in that column.\n        Collections.distinctive : Return distinctive values of Collections object.\n        ",
			"API_4": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/30": {
		"query": "I would like to sip all data in a monkey knowledgeframe Using kf.index to sip all rows",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "distinctive(self: '_IndexT', level: 'Hashable | None' = None) -> '_IndexT':\n        Return distinctive values in the index.\n\n        Unique values are returned in order of appearance, this does NOT sort.\n\n        Parameters\n        ----------\n        level : int or hashable, optional\n            Only return values from specified level (for MultiIndex).\n            If int, gettings the level by integer position, else by level name.\n\n        Returns\n        -------\n        Index\n\n        See Also\n        --------\n        distinctive : Numpy array of distinctive values in that column.\n        Collections.distinctive : Return distinctive values of Collections object.\n        ",
			"API_5": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/31": {
		"query": "I would like to add a new column C that is the sum value of A and B cell.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/32": {
		"query": "Move next value to first empty row monkey how do i move each value from a column to the first empty \"row/cell\" in monkey? use sorted to align non NULL data at the top, use sipna to sip all rows with all NaN",
		"retrieved_APIs": {
			"API_1": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_5": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/33": {
		"query": "I want to make all column headers in my monkey data frame lower case",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_5": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/35": {
		"query": "How to get the first largest value in column a\uff1f Using nbiggest and iloc to implemente this",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/36": {
		"query": "I have a Monkey knowledgeframe and I want to find all the unique values in that knowledgeframe...irrespective of row/columns. If I have a 10 x 10 knowledgeframe, and suppose they have 84 unique values, I need to find them - Not the count. Using xx.values.flat_underlying to get the flattened array of the knowledgeframe Getting the unique values by numpy.unique",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/37": {
		"query": "How to group values of monkey knowledgeframe and select the latest by date from each group? Sorting values by `date` (ascending is True), and then grouping by `id`",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/38": {
		"query": "i want to sip 2 rows in the knowledgeframe if zero comes in the column if 0 comes on odd index sip previous row as well as current row using monkey Assuming your knowledgeframe is indexed starting from 0 Rows with column2 = 0 and on odd index The rows above them A new knowledgeframe with those rows removed",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/39": {
		"query": "Shift column in monkey knowledgeframe up by one? In detail, in 'gdp' column, shift up by one and return knowledgeframe with the changed gdp column.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_4": "average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs):\nReturn the average of the values over the requested axis.\n\nParameters\n----------\naxis : {index (0)}\n    Axis for the function to be applied on.\nskipna : bool, default True\n    Exclude NA/null values when computing the result.\nlevel : int or level name, default None\n    If the axis is a MultiIndex (hierarchical), count along a\n    particular level, collapsing into a scalar.\nnumeric_only : bool, default None\n    Include only float, int, boolean columns. If None, will attempt to use\n    everything, then use only numeric data. Not implemented for Collections.\n**kwargs\n    Additional keyword arguments to be passed to the function.\n\nReturns\n-------\nscalar or Collections (if level specified)\n",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/40": {
		"query": "I was wondering if there is an elegant and shorthand way in Monkey KnowledgeFrames to select columns by data type (dtype). i.e. Select only float64 columns from a KnowledgeFrame",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/41": {
		"query": "How to unioner two knowledgeframes with different column names but same number of rows? I have two different data frames in monkey. Example: kf1=a b kf2= c 0 1 1 1 2 2 2 3 3 I want to unioner them so kf1= a b c 0 1 1 1 2 2 2 3 3 In order to unioner two knowledgeframes you can use this two examples. Both returns the same goal Using unioner plus additional arguments instructing it to use the indexes Specially, we can set left_index and right_index to True",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/42": {
		"query": "How can I delete multiple columns in one pass? In detail, I would like to delete columns A and C, but I don't know how to do it in one pass.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/43": {
		"query": "I want to get the counts of distinctive values of the knowledgeframe. count_values implements this however I want to use its output somewhere else. How can I convert .count_values output to a monkey knowledgeframe. Use renaming_axis('distinctive_values') for name ('counts') of column from index and reseting_index return the final knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_5": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/44": {
		"query": "How do I change the column labels of a monkey KnowledgeFrame from ['A', 'B', 'C'] to ['a', 'b', 'c']?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_4": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_5": "standard(self, axis=None, skipna=None, level=None, ddof=1, numeric_only=None, **kwargs):\nReturn sample_by_num standard deviation over requested axis.\n\nNormalized by N-1 by default. This can be changed using the ddof argument\n\nParameters\n----------\naxis : {index (0)}\nskipna : bool, default True\n    Exclude NA/null values. If an entire row/column is NA, the result\n    will be NA.\nlevel : int or level name, default None\n    If the axis is a MultiIndex (hierarchical), count along a\n    particular level, collapsing into a scalar.\nddof : int, default 1\n    Delta Degrees of Freedom. The divisionisor used in calculations is N - ddof,\n    where N represents the number of elements.\nnumeric_only : bool, default None\n    Include only float, int, boolean columns. If None, will attempt to use\n    everything, then use only numeric data. Not implemented for Collections.\n\nReturns\n-------\nscalar or Collections (if level specified)\n\nNotes\n-----\nTo have the same behaviour as `numpy.standard`, use `ddof=0` (instead of the\ndefault `ddof=1`)\n"
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/45": {
		"query": "I want to make all column headers in my monkey data frame lower case Return the changed knowledgeframe",
		"retrieved_APIs": {
			"API_1": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_2": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/46": {
		"query": "Say i have a knowledgeframe with 100,000 entries and want to split it into 100 sections of 1000 entries. How do i take a random sample of say size 50 of just one of the 100 sections. the data set is already ordered such that the first 1000 results are the first section the next section the next and so on. You could add a \"section\" column to your data then perform a grouper and sample_by_num(n=50):",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/47": {
		"query": "Example KnowledgeFrame Want to remove all the numbers from the Name column. Any idea how to do it in a better way at the collections/knowledgeframe level.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/48": {
		"query": "How do I find all rows in a monkey KnowledgeFrame which have the max value for 'num' column, after grouping by 'Mt' column?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/49": {
		"query": "transfer column date to datetime type when there is a string that is not capable of beeing turned into datetime format, skip that row, use errors='coerce' for this",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/50": {
		"query": "How to check if any value is NaN in a Monkey KnowledgeFrame? Return the result.",
		"retrieved_APIs": {
			"API_1": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_5": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/51": {
		"query": "Sorting columns in monkey knowledgeframe based on column name Note that axis is one",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "convert_dict(self, into=<class 'dict'>):\n        Convert Collections to {label -> value} dict or dict-like object.\n\n        Parameters\n        ----------\n        into : class, default dict\n            The collections.abc.Mapping subclass to use as the return\n            object. Can be the actual class or an empty\n            instance of the mappingping type you want.  If you want a\n            collections.defaultdict, you must pass it initialized.\n\n        Returns\n        -------\n        collections.abc.Mapping\n            Key-value representation of Collections.\n\n        Examples\n        --------\n        >>> s = mk.Collections([1, 2, 3, 4])\n        >>> s.convert_dict()\n        {0: 1, 1: 2, 2: 3, 3: 4}\n        >>> from collections import OrderedDict, defaultdict\n        >>> s.convert_dict(OrderedDict)\n        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n        >>> dd = defaultdict(list)\n        >>> s.convert_dict(dd)\n        defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n        ",
			"API_5": "interst(self, other, sort=False):\n        Form the interst of two Index objects.\n\n        This returns a new Index with elements common to the index and `other`.\n\n        Parameters\n        ----------\n        other : Index or array-like\n        sort : False or None, default False\n            Whether to sort the resulting index.\n\n            * False : do not sort the result.\n            * None : sort the result, except when `self` and `other` are equal\n              or when the values cannot be compared.\n\n        Returns\n        -------\n        interst : Index\n\n        Examples\n        --------\n        >>> idx1 = mk.Index([1, 2, 3, 4])\n        >>> idx2 = mk.Index([3, 4, 5, 6])\n        >>> idx1.interst(idx2)\n        Int64Index([3, 4], dtype='int64')\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/52": {
		"query": "How can I get the values of column `A` when column `B`=3?",
		"retrieved_APIs": {
			"API_1": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_2": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/53": {
		"query": "return the column average/mean",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame':\n        Apply a function to a Dataframe elementwise.\n\n        This method applies a function that accepts and returns a scalar\n        to every element of a KnowledgeFrame.\n\n        Parameters\n        ----------\n        func : ctotal_allable\n            Python function, returns a single value from a single value.\n        na_action : {None, 'ignore'}, default None\n            If \u2018ignore\u2019, propagate NaN values, without passing them to func.\n\n            .. versionadded:: 1.2\n\n        **kwargs\n            Additional keyword arguments to pass as keywords arguments to\n            `func`.\n\n            .. versionadded:: 1.3.0\n\n        Returns\n        -------\n        KnowledgeFrame\n            Transformed KnowledgeFrame.\n\n        See Also\n        --------\n        KnowledgeFrame.employ : Apply a function along input axis of KnowledgeFrame.\n\n        Examples\n        --------\n        >>> kf = mk.KnowledgeFrame([[1, 2.12], [3.356, 4.567]])\n        >>> kf\n               0      1\n        0  1.000  2.120\n        1  3.356  4.567\n\n        >>> kf.employmapping(lambda x: length(str(x)))\n           0  1\n        0  3  4\n        1  5  5\n\n        Like Collections.mapping, NA values can be ignored:\n\n        >>> kf_clone = kf.clone()\n        >>> kf_clone.iloc[0, 0] = mk.NA\n        >>> kf_clone.employmapping(lambda x: length(str(x)), na_action='ignore')\n              0  1\n        0  <NA>  4\n        1     5  5\n\n        Note that a vectorized version of `func` often exists, which will\n        be much faster. You could square each number elementwise.\n\n        >>> kf.employmapping(lambda x: x**2)\n                   0          1\n        0   1.000000   4.494400\n        1  11.262736  20.857489\n\n        But it's better to avoid employmapping in that case.\n\n        >>> kf ** 2\n                   0          1\n        0   1.000000   4.494400\n        1  11.262736  20.857489\n        ",
			"API_5": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/54": {
		"query": "How do I combine two knowledgeframes with ignore index? Return the concated knowledgeframe.",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "convert_dict(self, into=<class 'dict'>):\n        Convert Collections to {label -> value} dict or dict-like object.\n\n        Parameters\n        ----------\n        into : class, default dict\n            The collections.abc.Mapping subclass to use as the return\n            object. Can be the actual class or an empty\n            instance of the mappingping type you want.  If you want a\n            collections.defaultdict, you must pass it initialized.\n\n        Returns\n        -------\n        collections.abc.Mapping\n            Key-value representation of Collections.\n\n        Examples\n        --------\n        >>> s = mk.Collections([1, 2, 3, 4])\n        >>> s.convert_dict()\n        {0: 1, 1: 2, 2: 3, 3: 4}\n        >>> from collections import OrderedDict, defaultdict\n        >>> s.convert_dict(OrderedDict)\n        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n        >>> dd = defaultdict(list)\n        >>> s.convert_dict(dd)\n        defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/55": {
		"query": "This is my KnowledgeFrame that should be repeated for 5 times: I haven't found anything practical, including those like np.repeat ---- it just doesn't work on a KnowledgeFrame. You can use the concating function:",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_3": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd.",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/56": {
		"query": "Monkey KnowledgeFrame to List of Dictionaries Use kf.convert_dict() to solve it and return the result",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_3": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/57": {
		"query": "Convert Column `Date` to Date Format using monkey function return the coverted knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_5": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/58": {
		"query": "Counting consecutive positive values in Python/monkey array I'm trying to count consecutive up days in equity return data; so if a positive day is 1 and a negative is 0, a list y=[0,0,1,1,1,0,0,1,0,1,1] should return z=[0,0,1,2,3,0,0,1,0,1,2]. Return the result",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "remove_duplicates(self: '_IndexT', keep: 'str_t | bool' = 'first') -> '_IndexT':\n        Return Index with duplicate values removed.\n\n        Parameters\n        ----------\n        keep : {'first', 'final_item', ``False``}, default 'first'\n            - 'first' : Drop duplicates except for the first occurrence.\n            - 'final_item' : Drop duplicates except for the final_item occurrence.\n            - ``False`` : Drop total_all duplicates.\n\n        Returns\n        -------\n        deduplicated_values : Index\n\n        See Also\n        --------\n        Collections.sip_duplicates : Equivalengtht method on Collections.\n        KnowledgeFrame.sip_duplicates : Equivalengtht method on KnowledgeFrame.\n        Index.duplicated_values : Related method on Index, indicating duplicate\n            Index values.\n\n        Examples\n        --------\n        Generate an monkey.Index with duplicate values.\n\n        >>> idx = mk.Index(['lama', 'cow', 'lama', 'beetle', 'lama', 'hippo'])\n\n        The `keep` parameter controls  which duplicate values are removed.\n        The value 'first' keeps the first occurrence for each\n        set of duplicated_values entries. The default value of keep is 'first'.\n\n        >>> idx.sip_duplicates(keep='first')\n        Index(['lama', 'cow', 'beetle', 'hippo'], dtype='object')\n\n        The value 'final_item' keeps the final_item occurrence for each set of duplicated_values\n        entries.\n\n        >>> idx.sip_duplicates(keep='final_item')\n        Index(['cow', 'beetle', 'lama', 'hippo'], dtype='object')\n\n        The value ``False`` discards total_all sets of duplicated_values entries.\n\n        >>> idx.sip_duplicates(keep=False)\n        Index(['cow', 'beetle', 'hippo'], dtype='object')\n        ",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/59": {
		"query": "Inserts a row into a knowledgeframe at a specified row with no ingore index, and sort & reset the index with sip=True. Returns the new knowledgeframe.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "last_tail(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections':\n        Return the final_item `n` rows.\n\n        This function returns final_item `n` rows from the object based on\n        position. It is useful for quickly verifying data, for example,\n        after sorting or addinging rows.\n\n        For negative values of `n`, this function returns total_all rows except\n        the first `n` rows, equivalengtht to ``kf[n:]``.\n\n        Parameters\n        ----------\n        n : int, default 5\n            Number of rows to select.\n\n        Returns\n        -------\n        type of ctotal_aller\n            The final_item `n` rows of the ctotal_aller object.\n\n        See Also\n        --------\n        KnowledgeFrame.header_num : The first `n` rows of the ctotal_aller object.\n\n        Examples\n        --------\n        >>> kf = mk.KnowledgeFrame({'animal': ['total_alligator', 'bee', 'falcon', 'lion',\n        ...                    'monkey', 'parrot', 'shark', 'whale', 'zebra']})\n        >>> kf\n              animal\n        0  total_alligator\n        1        bee\n        2     falcon\n        3       lion\n        4     monkey\n        5     parrot\n        6      shark\n        7      whale\n        8      zebra\n\n        Viewing the final_item 5 lines\n\n        >>> kf.final_item_tail()\n           animal\n        4  monkey\n        5  parrot\n        6   shark\n        7   whale\n        8   zebra\n\n        Viewing the final_item `n` lines (three in this case)\n\n        >>> kf.final_item_tail(3)\n          animal\n        6  shark\n        7  whale\n        8  zebra\n\n        For negative values of `n`\n\n        >>> kf.final_item_tail(-3)\n           animal\n        3    lion\n        4  monkey\n        5  parrot\n        6   shark\n        7   whale\n        8   zebra\n        ",
			"API_3": "header_num(self: 'FrameOrCollections', n: 'int' = 5) -> 'FrameOrCollections':\n        Return the first `n` rows.\n\n        This function returns the first `n` rows for the object based\n        on position. It is useful for quickly testing if your object\n        has the right type of data in it.\n\n        For negative values of `n`, this function returns total_all rows except\n        the final_item `n` rows, equivalengtht to ``kf[:-n]``.\n\n        Parameters\n        ----------\n        n : int, default 5\n            Number of rows to select.\n\n        Returns\n        -------\n        same type as ctotal_aller\n            The first `n` rows of the ctotal_aller object.\n\n        See Also\n        --------\n        KnowledgeFrame.final_item_tail: Returns the final_item `n` rows.\n\n        Examples\n        --------\n        >>> kf = mk.KnowledgeFrame({'animal': ['total_alligator', 'bee', 'falcon', 'lion',\n        ...                    'monkey', 'parrot', 'shark', 'whale', 'zebra']})\n        >>> kf\n              animal\n        0  total_alligator\n        1        bee\n        2     falcon\n        3       lion\n        4     monkey\n        5     parrot\n        6      shark\n        7      whale\n        8      zebra\n\n        Viewing the first 5 lines\n\n        >>> kf.header_num()\n              animal\n        0  total_alligator\n        1        bee\n        2     falcon\n        3       lion\n        4     monkey\n\n        Viewing the first `n` lines (three in this case)\n\n        >>> kf.header_num(3)\n              animal\n        0  total_alligator\n        1        bee\n        2     falcon\n\n        For negative values of `n`\n\n        >>> kf.header_num(-3)\n              animal\n        0  total_alligator\n        1        bee\n        2     falcon\n        3       lion\n        4     monkey\n        5     parrot\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/60": {
		"query": "list_of_lists format: [header, [row1], [row2], ...] header format: [column1, column2, ...] row format: [value1, value2, ...] How to convert list to knowledgeframe? Return the knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs):\nReturn the average of the values over the requested axis.\n\nParameters\n----------\naxis : {index (0)}\n    Axis for the function to be applied on.\nskipna : bool, default True\n    Exclude NA/null values when computing the result.\nlevel : int or level name, default None\n    If the axis is a MultiIndex (hierarchical), count along a\n    particular level, collapsing into a scalar.\nnumeric_only : bool, default None\n    Include only float, int, boolean columns. If None, will attempt to use\n    everything, then use only numeric data. Not implemented for Collections.\n**kwargs\n    Additional keyword arguments to be passed to the function.\n\nReturns\n-------\nscalar or Collections (if level specified)\n",
			"API_3": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_4": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_5": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/61": {
		"query": "How do I unioner two knowledgeframes by index? Set left&right indexs to True",
		"retrieved_APIs": {
			"API_1": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_2": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/62": {
		"query": "How to obtain monkey KnowledgeFrame without index I want to print the whole knowledgeframe, but I don't want to print the index",
		"retrieved_APIs": {
			"API_1": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/63": {
		"query": "We will sip all Nan rows. Return the changed knowledgeframe.",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/64": {
		"query": "How to determine whether a Monkey Column contains a particular value? Return the result",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/65": {
		"query": "How would I rename the only one column header? return the changed knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/66": {
		"query": "I have a knowledgeframe with repeat values in column `col1`. I want to sip duplicates, keeping the row with the last value in column `col2`. How would I do that? return the final knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/67": {
		"query": "Monkey create empty KnowledgeFrame with only column names Return: KnowledgeFrame",
		"retrieved_APIs": {
			"API_1": "length(self):\n        Compute the lengthgth of each element in the Collections/Index.\n\n        The element may be a sequence (such as a string, tuple or list) or a collection\n        (such as a dictionary).\n\n        Returns\n        -------\n        Collections or Index of int\n            A Collections or Index of integer values indicating the lengthgth of each\n            element in the Collections or Index.\n\n        See Also\n        --------\n        str.length : Python built-in function returning the lengthgth of an object.\n        Collections.size : Returns the lengthgth of the Collections.\n\n        Examples\n        --------\n        Returns the lengthgth (number of characters) in a string. Returns the\n        number of entries for dictionaries, lists or tuples.\n\n        >>> s = mk.Collections(['dog',\n        ...                 '',\n        ...                 5,\n        ...                 {'foo' : 'bar'},\n        ...                 [2, 3, 5, 7],\n        ...                 ('one', 'two', 'three')])\n        >>> s\n        0                  dog\n        1\n        2                    5\n        3       {'foo': 'bar'}\n        4         [2, 3, 5, 7]\n        5    (one, two, three)\n        dtype: object\n        >>> s.str.length()\n        0    3.0\n        1    0.0\n        2    NaN\n        3    1.0\n        4    4.0\n        5    3.0\n        dtype: float64\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/68": {
		"query": "Delete first n rows of a knowledgeframe Input: kf: KnowledgeFrame n: int Return: KnowledgeFrame",
		"retrieved_APIs": {
			"API_1": "interst(self, other, sort=False):\n        Form the interst of two Index objects.\n\n        This returns a new Index with elements common to the index and `other`.\n\n        Parameters\n        ----------\n        other : Index or array-like\n        sort : False or None, default False\n            Whether to sort the resulting index.\n\n            * False : do not sort the result.\n            * None : sort the result, except when `self` and `other` are equal\n              or when the values cannot be compared.\n\n        Returns\n        -------\n        interst : Index\n\n        Examples\n        --------\n        >>> idx1 = mk.Index([1, 2, 3, 4])\n        >>> idx2 = mk.Index([3, 4, 5, 6])\n        >>> idx1.interst(idx2)\n        Int64Index([3, 4], dtype='int64')\n        ",
			"API_2": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_3": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        ",
			"API_4": "ifnull(self) -> 'np.ndarray':\n        Detect missing values.\n\n        Return a boolean same-sized object indicating if the values are NA.\n        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`mk.NaT`, getting\n        mappingped to ``True`` values.\n        Everything else getting mappingped to ``False`` values. Characters such as\n        empty strings `''` or :attr:`numpy.inf` are not considered NA values\n        (unless you set ``monkey.options.mode.use_inf_as_na = True``).\n\n        Returns\n        -------\n        numpy.ndarray[bool]\n            A boolean array of whether my values are NA.\n\n        See Also\n        --------\n        Index.notna : Boolean inverse of ifna.\n        Index.sipna : Omit entries with missing values.\n        ifna : Top-level ifna.\n        Collections.ifna : Detect missing values in Collections object.\n\n        Examples\n        --------\n        Show which entries in a monkey.Index are NA. The result is an\n        array.\n\n        >>> idx = mk.Index([5.2, 6.0, np.NaN])\n        >>> idx\n        Float64Index([5.2, 6.0, nan], dtype='float64')\n        >>> idx.ifna()\n        array([False, False,  True])\n\n        Empty strings are not considered NA values. None is considered an NA\n        value.\n\n        >>> idx = mk.Index(['black', '', 'red', None])\n        >>> idx\n        Index(['black', '', 'red', None], dtype='object')\n        >>> idx.ifna()\n        array([False, False, False,  True])\n\n        For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n        >>> idx = mk.DatetimeIndex([mk.Timestamp('1940-04-25'),\n        ...                         mk.Timestamp(''), None, mk.NaT])\n        >>> idx\n        DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                      dtype='datetime64[ns]', freq=None)\n        >>> idx.ifna()\n        array([False,  True,  True,  True])\n        ",
			"API_5": "ifna(self) -> 'np.ndarray':\n        Detect missing values.\n\n        Return a boolean same-sized object indicating if the values are NA.\n        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`mk.NaT`, getting\n        mappingped to ``True`` values.\n        Everything else getting mappingped to ``False`` values. Characters such as\n        empty strings `''` or :attr:`numpy.inf` are not considered NA values\n        (unless you set ``monkey.options.mode.use_inf_as_na = True``).\n\n        Returns\n        -------\n        numpy.ndarray[bool]\n            A boolean array of whether my values are NA.\n\n        See Also\n        --------\n        Index.notna : Boolean inverse of ifna.\n        Index.sipna : Omit entries with missing values.\n        ifna : Top-level ifna.\n        Collections.ifna : Detect missing values in Collections object.\n\n        Examples\n        --------\n        Show which entries in a monkey.Index are NA. The result is an\n        array.\n\n        >>> idx = mk.Index([5.2, 6.0, np.NaN])\n        >>> idx\n        Float64Index([5.2, 6.0, nan], dtype='float64')\n        >>> idx.ifna()\n        array([False, False,  True])\n\n        Empty strings are not considered NA values. None is considered an NA\n        value.\n\n        >>> idx = mk.Index(['black', '', 'red', None])\n        >>> idx\n        Index(['black', '', 'red', None], dtype='object')\n        >>> idx.ifna()\n        array([False, False, False,  True])\n\n        For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n        >>> idx = mk.DatetimeIndex([mk.Timestamp('1940-04-25'),\n        ...                         mk.Timestamp(''), None, mk.NaT])\n        >>> idx\n        DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                      dtype='datetime64[ns]', freq=None)\n        >>> idx.ifna()\n        array([False,  True,  True,  True])\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/69": {
		"query": "Here's a one solution to remove columns based on duplicate column names: Return the duplicated knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_2": "shifting(self, periods=1, freq=None):\n        Shift index by desired number of time frequency increments.\n\n        This method is for shiftinging the values of datetime-like indexes\n        by a specified time increment a given number of times.\n\n        Parameters\n        ----------\n        periods : int, default 1\n            Number of periods (or increments) to shifting by,\n            can be positive or negative.\n        freq : monkey.DateOffset, monkey.Timedelta or str, optional\n            Frequency increment to shifting by.\n            If None, the index is shiftinged by its own `freq` attribute.\n            Offset aliases are valid strings, e.g., 'D', 'W', 'M' etc.\n\n        Returns\n        -------\n        monkey.Index\n            Shifted index.\n\n        See Also\n        --------\n        Collections.shifting : Shift values of Collections.\n\n        Notes\n        -----\n        This method is only implemented for datetime-like index classes,\n        i.e., DatetimeIndex, PeriodIndex and TimedeltaIndex.\n\n        Examples\n        --------\n        Put the first 5 month starts of 2011 into an index.\n\n        >>> month_starts = mk.date_range('1/1/2011', periods=5, freq='MS')\n        >>> month_starts\n        DatetimeIndex(['2011-01-01', '2011-02-01', '2011-03-01', '2011-04-01',\n                       '2011-05-01'],\n                      dtype='datetime64[ns]', freq='MS')\n\n        Shift the index by 10 days.\n\n        >>> month_starts.shifting(10, freq='D')\n        DatetimeIndex(['2011-01-11', '2011-02-11', '2011-03-11', '2011-04-11',\n                       '2011-05-11'],\n                      dtype='datetime64[ns]', freq=None)\n\n        The default value of `freq` is the `freq` attribute of the index,\n        which is 'MS' (month start) in this example.\n\n        >>> month_starts.shifting(10)\n        DatetimeIndex(['2011-11-01', '2011-12-01', '2012-01-01', '2012-02-01',\n                       '2012-03-01'],\n                      dtype='datetime64[ns]', freq='MS')\n        ",
			"API_3": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd.",
			"API_4": "interst(self, other, sort=False):\n        Form the interst of two Index objects.\n\n        This returns a new Index with elements common to the index and `other`.\n\n        Parameters\n        ----------\n        other : Index or array-like\n        sort : False or None, default False\n            Whether to sort the resulting index.\n\n            * False : do not sort the result.\n            * None : sort the result, except when `self` and `other` are equal\n              or when the values cannot be compared.\n\n        Returns\n        -------\n        interst : Index\n\n        Examples\n        --------\n        >>> idx1 = mk.Index([1, 2, 3, 4])\n        >>> idx2 = mk.Index([3, 4, 5, 6])\n        >>> idx1.interst(idx2)\n        Int64Index([3, 4], dtype='int64')\n        ",
			"API_5": "fillnone(self, value=None, downcast=None):\n        Fill NA/NaN values with the specified value.\n\n        Parameters\n        ----------\n        value : scalar\n            Scalar value to use to fill holes (e.g. 0).\n            This value cannot be a list-likes.\n        downcast : dict, default is None\n            A dict of item->dtype of what to downcast if possible,\n            or the string 'infer' which will try to downcast to an appropriate\n            equal type (e.g. float64 to int64 if possible).\n\n        Returns\n        -------\n        Index\n\n        See Also\n        --------\n        KnowledgeFrame.fillnone : Fill NaN values of a KnowledgeFrame.\n        Collections.fillnone : Fill NaN Values of a Collections.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/70": {
		"query": "How can I map True/False to 1/0 in a Monkey KnowledgeFrame? return the knowledgeframe with the column converted to int",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/71": {
		"query": "How do I retrieve the number of columns in a Monkey data frame? Return the number of columns in the knowledgeframe",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "convert_dict(self, into=<class 'dict'>):\n        Convert Collections to {label -> value} dict or dict-like object.\n\n        Parameters\n        ----------\n        into : class, default dict\n            The collections.abc.Mapping subclass to use as the return\n            object. Can be the actual class or an empty\n            instance of the mappingping type you want.  If you want a\n            collections.defaultdict, you must pass it initialized.\n\n        Returns\n        -------\n        collections.abc.Mapping\n            Key-value representation of Collections.\n\n        Examples\n        --------\n        >>> s = mk.Collections([1, 2, 3, 4])\n        >>> s.convert_dict()\n        {0: 1, 1: 2, 2: 3, 3: 4}\n        >>> from collections import OrderedDict, defaultdict\n        >>> s.convert_dict(OrderedDict)\n        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n        >>> dd = defaultdict(list)\n        >>> s.convert_dict(dd)\n        defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n        ",
			"API_5": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/72": {
		"query": "How do I determine which columns contain NaN values? In particular, can I get a list of the column names containing NaNs? Return a list of the column names containing NaNs",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "convert_dict(self, into=<class 'dict'>):\n        Convert Collections to {label -> value} dict or dict-like object.\n\n        Parameters\n        ----------\n        into : class, default dict\n            The collections.abc.Mapping subclass to use as the return\n            object. Can be the actual class or an empty\n            instance of the mappingping type you want.  If you want a\n            collections.defaultdict, you must pass it initialized.\n\n        Returns\n        -------\n        collections.abc.Mapping\n            Key-value representation of Collections.\n\n        Examples\n        --------\n        >>> s = mk.Collections([1, 2, 3, 4])\n        >>> s.convert_dict()\n        {0: 1, 1: 2, 2: 3, 3: 4}\n        >>> from collections import OrderedDict, defaultdict\n        >>> s.convert_dict(OrderedDict)\n        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n        >>> dd = defaultdict(list)\n        >>> s.convert_dict(dd)\n        defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/73": {
		"query": "How to get the last N rows of a monkey KnowledgeFrame?",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_4": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_5": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/74": {
		"query": "replace field that's entirely space (or empty) with NaN using regex return the result",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/75": {
		"query": "Monkey knowledgeframe fillnone() only some columns in place This function fills all columns with 0 Return the changed knowledgeframe",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_4": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        ",
			"API_5": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/76": {
		"query": "Given that all the knowledgeframes have the same columns, you can simply concat them: return the concated knowledgeframe",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_3": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/77": {
		"query": "Extract first and last row of a knowledgeframe in monkey Return the knowledgeframe with the first and last row",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "convert_dict(self, into=<class 'dict'>):\n        Convert Collections to {label -> value} dict or dict-like object.\n\n        Parameters\n        ----------\n        into : class, default dict\n            The collections.abc.Mapping subclass to use as the return\n            object. Can be the actual class or an empty\n            instance of the mappingping type you want.  If you want a\n            collections.defaultdict, you must pass it initialized.\n\n        Returns\n        -------\n        collections.abc.Mapping\n            Key-value representation of Collections.\n\n        Examples\n        --------\n        >>> s = mk.Collections([1, 2, 3, 4])\n        >>> s.convert_dict()\n        {0: 1, 1: 2, 2: 3, 3: 4}\n        >>> from collections import OrderedDict, defaultdict\n        >>> s.convert_dict(OrderedDict)\n        OrderedDict([(0, 1), (1, 2), (2, 3), (3, 4)])\n        >>> dd = defaultdict(list)\n        >>> s.convert_dict(dd)\n        defaultdict(<class 'list'>, {0: 1, 1: 2, 2: 3, 3: 4})\n        ",
			"API_5": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/78": {
		"query": "Return the knowledgeframe with the rows with one or more NaN values",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/79": {
		"query": "Return the row-index values of the knowledgeframe as a list",
		"retrieved_APIs": {
			"API_1": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_2": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_3": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/80": {
		"query": "I find myself often having to check whether a column or row exists in a knowledgeframe before trying to reference it. Is there any way to do this more nicely? For example on an arbitrary object I can do x = getattr(anobject, 'id', default) - is there anything similar to this in monkey? Really any way to achieve what I'm doing more gracefully? Output the second row of data in `mycol` column if it exists, otherwise output NaN",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/81": {
		"query": "Count the number of occurrences of a value in a collections Return the count",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_4": "clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT':\n        Make a clone of this object.\n\n        Name and dtype sets those attributes on the new object.\n\n        Parameters\n        ----------\n        name : Label, optional\n            Set name for new object.\n        deep : bool, default False\n        dtype : numpy dtype or monkey type, optional\n            Set dtype for new object.\n\n            .. deprecated:: 1.2.0\n                use ``totype`` method instead.\n        names : list-like, optional\n            Kept for compatibility with MultiIndex. Should not be used.\n\n        Returns\n        -------\n        Index\n            Index refer to new object which is a clone of this object.\n\n        Notes\n        -----\n        In most cases, there should be no functional difference from using\n        ``deep``, but if ``deep`` is passed it will attempt to deepclone.\n        ",
			"API_5": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/82": {
		"query": "Find rows in kf where col_a > col_b Return the rows",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT':\n        Make a clone of this object.\n\n        Name and dtype sets those attributes on the new object.\n\n        Parameters\n        ----------\n        name : Label, optional\n            Set name for new object.\n        deep : bool, default False\n        dtype : numpy dtype or monkey type, optional\n            Set dtype for new object.\n\n            .. deprecated:: 1.2.0\n                use ``totype`` method instead.\n        names : list-like, optional\n            Kept for compatibility with MultiIndex. Should not be used.\n\n        Returns\n        -------\n        Index\n            Index refer to new object which is a clone of this object.\n\n        Notes\n        -----\n        In most cases, there should be no functional difference from using\n        ``deep``, but if ``deep`` is passed it will attempt to deepclone.\n        ",
			"API_3": "fillnone(self, value=None, downcast=None):\n        Fill NA/NaN values with the specified value.\n\n        Parameters\n        ----------\n        value : scalar\n            Scalar value to use to fill holes (e.g. 0).\n            This value cannot be a list-likes.\n        downcast : dict, default is None\n            A dict of item->dtype of what to downcast if possible,\n            or the string 'infer' which will try to downcast to an appropriate\n            equal type (e.g. float64 to int64 if possible).\n\n        Returns\n        -------\n        Index\n\n        See Also\n        --------\n        KnowledgeFrame.fillnone : Fill NaN values of a KnowledgeFrame.\n        Collections.fillnone : Fill NaN Values of a Collections.\n        ",
			"API_4": "interst(self, other, sort=False):\n        Form the interst of two Index objects.\n\n        This returns a new Index with elements common to the index and `other`.\n\n        Parameters\n        ----------\n        other : Index or array-like\n        sort : False or None, default False\n            Whether to sort the resulting index.\n\n            * False : do not sort the result.\n            * None : sort the result, except when `self` and `other` are equal\n              or when the values cannot be compared.\n\n        Returns\n        -------\n        interst : Index\n\n        Examples\n        --------\n        >>> idx1 = mk.Index([1, 2, 3, 4])\n        >>> idx2 = mk.Index([3, 4, 5, 6])\n        >>> idx1.interst(idx2)\n        Int64Index([3, 4], dtype='int64')\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/83": {
		"query": "Drop consecutive duplicates Return the result",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "conduct_map(self, func: 'PythonFuncType', na_action: 'str | None' = None, **kwargs) -> 'KnowledgeFrame':\n        Apply a function to a Dataframe elementwise.\n\n        This method applies a function that accepts and returns a scalar\n        to every element of a KnowledgeFrame.\n\n        Parameters\n        ----------\n        func : ctotal_allable\n            Python function, returns a single value from a single value.\n        na_action : {None, 'ignore'}, default None\n            If \u2018ignore\u2019, propagate NaN values, without passing them to func.\n\n            .. versionadded:: 1.2\n\n        **kwargs\n            Additional keyword arguments to pass as keywords arguments to\n            `func`.\n\n            .. versionadded:: 1.3.0\n\n        Returns\n        -------\n        KnowledgeFrame\n            Transformed KnowledgeFrame.\n\n        See Also\n        --------\n        KnowledgeFrame.employ : Apply a function along input axis of KnowledgeFrame.\n\n        Examples\n        --------\n        >>> kf = mk.KnowledgeFrame([[1, 2.12], [3.356, 4.567]])\n        >>> kf\n               0      1\n        0  1.000  2.120\n        1  3.356  4.567\n\n        >>> kf.employmapping(lambda x: length(str(x)))\n           0  1\n        0  3  4\n        1  5  5\n\n        Like Collections.mapping, NA values can be ignored:\n\n        >>> kf_clone = kf.clone()\n        >>> kf_clone.iloc[0, 0] = mk.NA\n        >>> kf_clone.employmapping(lambda x: length(str(x)), na_action='ignore')\n              0  1\n        0  <NA>  4\n        1     5  5\n\n        Note that a vectorized version of `func` often exists, which will\n        be much faster. You could square each number elementwise.\n\n        >>> kf.employmapping(lambda x: x**2)\n                   0          1\n        0   1.000000   4.494400\n        1  11.262736  20.857489\n\n        But it's better to avoid employmapping in that case.\n\n        >>> kf ** 2\n                   0          1\n        0   1.000000   4.494400\n        1  11.262736  20.857489\n        ",
			"API_5": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/84": {
		"query": "Round a single column `A` Return the knowledgeframe",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/85": {
		"query": "Add Leading Zeros to Strings at `col_name` in Monkey Dataframe The maximum length of the string is 15 Return the knowledgeframe",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_3": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_4": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd.",
			"API_5": "average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs):\nReturn the average of the values over the requested axis.\n\nParameters\n----------\naxis : {index (0)}\n    Axis for the function to be applied on.\nskipna : bool, default True\n    Exclude NA/null values when computing the result.\nlevel : int or level name, default None\n    If the axis is a MultiIndex (hierarchical), count along a\n    particular level, collapsing into a scalar.\nnumeric_only : bool, default None\n    Include only float, int, boolean columns. If None, will attempt to use\n    everything, then use only numeric data. Not implemented for Collections.\n**kwargs\n    Additional keyword arguments to be passed to the function.\n\nReturns\n-------\nscalar or Collections (if level specified)\n"
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/86": {
		"query": "adding dictionary to data frame return the data frame",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/87": {
		"query": "transform timestamp to pydatetime object return pydatetime object",
		"retrieved_APIs": {
			"API_1": "incontain(self, values) -> 'np.ndarray': Return a boolean array where True if the value is contained in the passed values.",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        ",
			"API_4": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_5": "get_max(self, axis=None, skipna: 'bool' = True, *args, **kwargs):\n        Return the getting_maximum value of the Index.\n\n        Parameters\n        ----------\n        axis : int, optional\n            For compatibility with NumPy. Only 0 or None are total_allowed.\n        skipna : bool, default True\n            Exclude NA/null values when showing the result.\n        *args, **kwargs\n            Additional arguments and keywords for compatibility with NumPy.\n\n        Returns\n        -------\n        scalar\n            Maximum value.\n\n        See Also\n        --------\n        Index.getting_min : Return the getting_minimum value in an Index.\n        Collections.getting_max : Return the getting_maximum value in a Collections.\n        KnowledgeFrame.getting_max : Return the getting_maximum values in a KnowledgeFrame.\n\n        Examples\n        --------\n        >>> idx = mk.Index([3, 2, 1])\n        >>> idx.getting_max()\n        3\n\n        >>> idx = mk.Index(['c', 'b', 'a'])\n        >>> idx.getting_max()\n        'c'\n\n        For a MultiIndex, the getting_maximum is detergetting_mined lexicographictotal_ally.\n\n        >>> idx = mk.MultiIndex.from_product([('a', 'b'), (2, 1)])\n        >>> idx.getting_max()\n        ('b', 2)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/88": {
		"query": "Given a monkey collections that represents frequencies of a value, how can I turn those frequencies into percentages? Return the percentage of each gender.",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_5": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/89": {
		"query": "I need to divide all ['B','C'] columns but the first column 'A' in a KnowledgeFrame by the first column. Return the result.",
		"retrieved_APIs": {
			"API_1": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_2": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_5": "totype(self, dtype: 'Dtype | None' = None, clone=True):\n        Change the dtype of a SparseArray.\n\n        The output will always be a SparseArray. To convert to a dense\n        ndarray with a certain dtype, use :meth:`numpy.asarray`.\n\n        Parameters\n        ----------\n        dtype : np.dtype or ExtensionDtype\n            For SparseDtype, this changes the dtype of\n            ``self.sp_values`` and the ``self.fill_value``.\n\n            For other dtypes, this only changes the dtype of\n            ``self.sp_values``.\n\n        clone : bool, default True\n            Whether to ensure a clone is made, even if not necessary.\n\n        Returns\n        -------\n        SparseArray\n\n        Examples\n        --------\n        >>> arr = mk.arrays.SparseArray([0, 0, 1, 2])\n        >>> arr\n        [0, 0, 1, 2]\n        Fill: 0\n        IntIndex\n        Indices: array([2, 3], dtype=int32)\n\n        >>> arr.totype(np.dtype('int32'))\n        [0, 0, 1, 2]\n        Fill: 0\n        IntIndex\n        Indices: array([2, 3], dtype=int32)\n\n        Using a NumPy dtype with a different kind (e.g. float) will coerce\n        just ``self.sp_values``.\n\n        >>> arr.totype(np.dtype('float64'))\n        ... # doctest: +NORMALIZE_WHITESPACE\n        [0.0, 0.0, 1.0, 2.0]\n        Fill: 0.0\n        IntIndex\n        Indices: array([2, 3], dtype=int32)\n\n        Use a SparseDtype if you wish to be change the fill value as well.\n\n        >>> arr.totype(SparseDtype(\"float64\", fill_value=np.nan))\n        ... # doctest: +NORMALIZE_WHITESPACE\n        [nan, nan, 1.0, 2.0]\n        Fill: nan\n        IntIndex\n        Indices: array([2, 3], dtype=int32)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/90": {
		"query": "ceiling of a monkey collections Return the result.",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_5": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/91": {
		"query": "Delete all columns that contain all NaN values Return the result.",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT':\n        Make a clone of this object.\n\n        Name and dtype sets those attributes on the new object.\n\n        Parameters\n        ----------\n        name : Label, optional\n            Set name for new object.\n        deep : bool, default False\n        dtype : numpy dtype or monkey type, optional\n            Set dtype for new object.\n\n            .. deprecated:: 1.2.0\n                use ``totype`` method instead.\n        names : list-like, optional\n            Kept for compatibility with MultiIndex. Should not be used.\n\n        Returns\n        -------\n        Index\n            Index refer to new object which is a clone of this object.\n\n        Notes\n        -----\n        In most cases, there should be no functional difference from using\n        ``deep``, but if ``deep`` is passed it will attempt to deepclone.\n        ",
			"API_4": "renaming(self, name, inplace=False):\n        Alter Index or MultiIndex name.\n\n        Able to set new names without level. Defaults to returning new index.\n        Length of names must match number of levels in MultiIndex.\n\n        Parameters\n        ----------\n        name : label or list of labels\n            Name(s) to set.\n        inplace : bool, default False\n            Modifies the object directly, instead of creating a new Index or\n            MultiIndex.\n\n        Returns\n        -------\n        Index or None\n            The same type as the ctotal_aller or None if ``inplace=True``.\n\n        See Also\n        --------\n        Index.set_names : Able to set new names partitotal_ally and by level.\n\n        Examples\n        --------\n        >>> idx = mk.Index(['A', 'C', 'A', 'B'], name='score')\n        >>> idx.renagetting_ming('grade')\n        Index(['A', 'C', 'A', 'B'], dtype='object', name='grade')\n\n        >>> idx = mk.MultiIndex.from_product([['python', 'cobra'],\n        ...                                   [2018, 2019]],\n        ...                                   names=['kind', 'year'])\n        >>> idx\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['kind', 'year'])\n        >>> idx.renagetting_ming(['species', 'year'])\n        MultiIndex([('python', 2018),\n                    ('python', 2019),\n                    ( 'cobra', 2018),\n                    ( 'cobra', 2019)],\n                   names=['species', 'year'])\n        >>> idx.renagetting_ming('species')\n        Traceback (most recent ctotal_all final_item):\n        TypeError: Must pass list-like as `names`.\n        ",
			"API_5": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/92": {
		"query": "add the row at top in kf resort the index by inplace",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT':\n        Make a clone of this object.\n\n        Name and dtype sets those attributes on the new object.\n\n        Parameters\n        ----------\n        name : Label, optional\n            Set name for new object.\n        deep : bool, default False\n        dtype : numpy dtype or monkey type, optional\n            Set dtype for new object.\n\n            .. deprecated:: 1.2.0\n                use ``totype`` method instead.\n        names : list-like, optional\n            Kept for compatibility with MultiIndex. Should not be used.\n\n        Returns\n        -------\n        Index\n            Index refer to new object which is a clone of this object.\n\n        Notes\n        -----\n        In most cases, there should be no functional difference from using\n        ``deep``, but if ``deep`` is passed it will attempt to deepclone.\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/93": {
		"query": "Set value to an entire column `B` of a monkey knowledgeframe Return the changed knowledgeframe.",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "sip(self, labels, errors: 'str_t' = 'raise') -> 'Index':\n        Make new Index with passed list of labels deleted.\n\n        Parameters\n        ----------\n        labels : array-like\n        errors : {'ignore', 'raise'}, default 'raise'\n            If 'ignore', suppress error and existing labels are sipped.\n\n        Returns\n        -------\n        sipped : Index\n            Will be same type as self, except for RangeIndex.\n\n        Raises\n        ------\n        KeyError\n            If not total_all of the labels are found in the selected axis\n        ",
			"API_3": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/94": {
		"query": "Finding the intersection between two collections In detail, first we create two sets, one for each collections. Then we find the intersection of the two sets.",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_4": "ifnull(self) -> 'np.ndarray':\n        Detect missing values.\n\n        Return a boolean same-sized object indicating if the values are NA.\n        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`mk.NaT`, getting\n        mappingped to ``True`` values.\n        Everything else getting mappingped to ``False`` values. Characters such as\n        empty strings `''` or :attr:`numpy.inf` are not considered NA values\n        (unless you set ``monkey.options.mode.use_inf_as_na = True``).\n\n        Returns\n        -------\n        numpy.ndarray[bool]\n            A boolean array of whether my values are NA.\n\n        See Also\n        --------\n        Index.notna : Boolean inverse of ifna.\n        Index.sipna : Omit entries with missing values.\n        ifna : Top-level ifna.\n        Collections.ifna : Detect missing values in Collections object.\n\n        Examples\n        --------\n        Show which entries in a monkey.Index are NA. The result is an\n        array.\n\n        >>> idx = mk.Index([5.2, 6.0, np.NaN])\n        >>> idx\n        Float64Index([5.2, 6.0, nan], dtype='float64')\n        >>> idx.ifna()\n        array([False, False,  True])\n\n        Empty strings are not considered NA values. None is considered an NA\n        value.\n\n        >>> idx = mk.Index(['black', '', 'red', None])\n        >>> idx\n        Index(['black', '', 'red', None], dtype='object')\n        >>> idx.ifna()\n        array([False, False, False,  True])\n\n        For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n        >>> idx = mk.DatetimeIndex([mk.Timestamp('1940-04-25'),\n        ...                         mk.Timestamp(''), None, mk.NaT])\n        >>> idx\n        DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                      dtype='datetime64[ns]', freq=None)\n        >>> idx.ifna()\n        array([False,  True,  True,  True])\n        ",
			"API_5": "ifna(self) -> 'np.ndarray':\n        Detect missing values.\n\n        Return a boolean same-sized object indicating if the values are NA.\n        NA values, such as ``None``, :attr:`numpy.NaN` or :attr:`mk.NaT`, getting\n        mappingped to ``True`` values.\n        Everything else getting mappingped to ``False`` values. Characters such as\n        empty strings `''` or :attr:`numpy.inf` are not considered NA values\n        (unless you set ``monkey.options.mode.use_inf_as_na = True``).\n\n        Returns\n        -------\n        numpy.ndarray[bool]\n            A boolean array of whether my values are NA.\n\n        See Also\n        --------\n        Index.notna : Boolean inverse of ifna.\n        Index.sipna : Omit entries with missing values.\n        ifna : Top-level ifna.\n        Collections.ifna : Detect missing values in Collections object.\n\n        Examples\n        --------\n        Show which entries in a monkey.Index are NA. The result is an\n        array.\n\n        >>> idx = mk.Index([5.2, 6.0, np.NaN])\n        >>> idx\n        Float64Index([5.2, 6.0, nan], dtype='float64')\n        >>> idx.ifna()\n        array([False, False,  True])\n\n        Empty strings are not considered NA values. None is considered an NA\n        value.\n\n        >>> idx = mk.Index(['black', '', 'red', None])\n        >>> idx\n        Index(['black', '', 'red', None], dtype='object')\n        >>> idx.ifna()\n        array([False, False, False,  True])\n\n        For datetimes, `NaT` (Not a Time) is considered as an NA value.\n\n        >>> idx = mk.DatetimeIndex([mk.Timestamp('1940-04-25'),\n        ...                         mk.Timestamp(''), None, mk.NaT])\n        >>> idx\n        DatetimeIndex(['1940-04-25', 'NaT', 'NaT', 'NaT'],\n                      dtype='datetime64[ns]', freq=None)\n        >>> idx.ifna()\n        array([False,  True,  True,  True])\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/95": {
		"query": "I would simply like to slice the Data Frame and take the first n rows. Return the result",
		"retrieved_APIs": {
			"API_1": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_4": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_5": "getting(self, i):\n        Extract element from each component at specified position.\n\n        Extract element from lists, tuples, or strings in each element in the\n        Collections/Index.\n\n        Parameters\n        ----------\n        i : int\n            Position of element to extract.\n\n        Returns\n        -------\n        Collections or Index\n\n        Examples\n        --------\n        >>> s = mk.Collections([\"String\",\n        ...               (1, 2, 3),\n        ...               [\"a\", \"b\", \"c\"],\n        ...               123,\n        ...               -456,\n        ...               {1: \"Hello\", \"2\": \"World\"}])\n        >>> s\n        0                        String\n        1                     (1, 2, 3)\n        2                     [a, b, c]\n        3                           123\n        4                          -456\n        5    {1: 'Hello', '2': 'World'}\n        dtype: object\n\n        >>> s.str.getting(1)\n        0        t\n        1        2\n        2        b\n        3      NaN\n        4      NaN\n        5    Hello\n        dtype: object\n\n        >>> s.str.getting(-1)\n        0      g\n        1      3\n        2      c\n        3    NaN\n        4    NaN\n        5    None\n        dtype: object\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/96": {
		"query": "Add a new column named 'Fruit Total' that sums the values of the other columns Note that igonring the NaN values",
		"retrieved_APIs": {
			"API_1": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_2": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_5": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/97": {
		"query": "Finding non-numeric rows in knowledgeframe in monkey Return the raws that contain non-numeric values So to get the subKnowledgeFrame of rouges, (Note: the negation, ~, of the above finds the ones which have at least one rogue non-numeric):",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "replacing(old, new, count=-1, /):Return a clone with total_all occurrences of substring old replacingd by new.\n\n  count\n    Maximum number of occurrences to replacing.\n    -1 (the default value) averages replacing total_all occurrences.\n\nIf the optional argument count is given, only the first count occurrences are\nreplacingd."
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/98": {
		"query": "unioner the above two knowledgeframes on column 'company'",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "whatever(self, *args, **kwargs):\n        Return whether whatever element is Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        whatever : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.total_all : Return whether total_all elements are True.\n        Collections.total_all : Return whether total_all elements are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        >>> index = mk.Index([0, 1, 2])\n        >>> index.whatever()\n        True\n\n        >>> index = mk.Index([0, 0, 0])\n        >>> index.whatever()\n        False\n        ",
			"API_3": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_4": "total_all(self, *args, **kwargs):\n        Return whether total_all elements are Truthy.\n\n        Parameters\n        ----------\n        *args\n            Required for compatibility with numpy.\n        **kwargs\n            Required for compatibility with numpy.\n\n        Returns\n        -------\n        total_all : bool or array-like (if axis is specified)\n            A single element array-like may be converted to bool.\n\n        See Also\n        --------\n        Index.whatever : Return whether whatever element in an Index is True.\n        Collections.whatever : Return whether whatever element in a Collections is True.\n        Collections.total_all : Return whether total_all elements in a Collections are True.\n\n        Notes\n        -----\n        Not a Number (NaN), positive infinity and negative infinity\n        evaluate to True because these are not equal to zero.\n\n        Examples\n        --------\n        **total_all**\n\n        True, because nonzero integers are considered True.\n\n        >>> mk.Index([1, 2, 3]).total_all()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 1, 2]).total_all()\n        False\n\n        **whatever**\n\n        True, because ``1`` is considered True.\n\n        >>> mk.Index([0, 0, 1]).whatever()\n        True\n\n        False, because ``0`` is considered False.\n\n        >>> mk.Index([0, 0, 0]).whatever()\n        False\n        ",
			"API_5": "convert_list(self, *args, **kwargs):\n        Return a list of the values.\n\n        These are each a scalar type, which is a Python scalar\n        (for str, int, float) or a monkey scalar\n        (for Timestamp/Timedelta/Interval/Period)\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/99": {
		"query": "counting the number of missing/NaN in each column Get a collections with the number of missing/NaN in each column",
		"retrieved_APIs": {
			"API_1": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_2": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        ",
			"API_3": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "clone(self: '_IndexT', name: 'Hashable | None' = None, deep: 'bool' = False, dtype: 'Dtype | None' = None, names: 'Sequence[Hashable] | None' = None) -> '_IndexT':\n        Make a clone of this object.\n\n        Name and dtype sets those attributes on the new object.\n\n        Parameters\n        ----------\n        name : Label, optional\n            Set name for new object.\n        deep : bool, default False\n        dtype : numpy dtype or monkey type, optional\n            Set dtype for new object.\n\n            .. deprecated:: 1.2.0\n                use ``totype`` method instead.\n        names : list-like, optional\n            Kept for compatibility with MultiIndex. Should not be used.\n\n        Returns\n        -------\n        Index\n            Index refer to new object which is a clone of this object.\n\n        Notes\n        -----\n        In most cases, there should be no functional difference from using\n        ``deep``, but if ``deep`` is passed it will attempt to deepclone.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/100": {
		"query": "Any word from `targets` are present in sentence.",
		"retrieved_APIs": {
			"API_1": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_2": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "mapping(self, mapper, na_action=None):\n        Map values using input correspondence (a dict, Collections, or function).\n\n        Parameters\n        ----------\n        mappingper : function, dict, or Collections\n            Mapping correspondence.\n        na_action : {None, 'ignore'}\n            If 'ignore', propagate NA values, without passing them to the\n            mappingping correspondence.\n\n        Returns\n        -------\n        applied : Union[Index, MultiIndex], inferred\n            The output of the mappingping function applied to the index.\n            If the function returns a tuple with more than one element\n            a MultiIndex will be returned.\n        ",
			"API_5": "average(self, axis=None, skipna=None, level=None, numeric_only=None, **kwargs):\nReturn the average of the values over the requested axis.\n\nParameters\n----------\naxis : {index (0)}\n    Axis for the function to be applied on.\nskipna : bool, default True\n    Exclude NA/null values when computing the result.\nlevel : int or level name, default None\n    If the axis is a MultiIndex (hierarchical), count along a\n    particular level, collapsing into a scalar.\nnumeric_only : bool, default None\n    Include only float, int, boolean columns. If None, will attempt to use\n    everything, then use only numeric data. Not implemented for Collections.\n**kwargs\n    Additional keyword arguments to be passed to the function.\n\nReturns\n-------\nscalar or Collections (if level specified)\n"
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/34": {
		"query": "I need to calculate the difference between two rows groupwise using monkey. To calculate the total_sum I would use monkey.grouper('Group').total_sum(), but how do you calculate the difference between rows where the row ordering is important? I think we need custom function with employ which return KnowledgeFrame for each group, for select by position is used iat: Return the result",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_3": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_4": "get_min(self, *, skipna=True, **kwargs):\n        The getting_minimum value of the object.\n\n        Only ordered `Categoricals` have a getting_minimum!\n\n        .. versionchanged:: 1.0.0\n\n           Returns an NA value on empty arrays\n\n        Raises\n        ------\n        TypeError\n            If the `Categorical` is not `ordered`.\n\n        Returns\n        -------\n        getting_min : the getting_minimum of this `Categorical`\n        ",
			"API_5": "flat_underlying(self, order='C'):\n        Return an ndarray of the flattened values of the underlying data.\n\n        Returns\n        -------\n        numpy.ndarray\n            Flattened array.\n\n        See Also\n        --------\n        numpy.ndarray.flat_underlying : Return a flattened array.\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	},
	"PandasEval/27": {
		"query": "Normalization using monkey We simply subtract the average and divide by standard deviation on kf.iloc[:,0,-1] obj with axis is zero. Return the normalized knowledgeframe",
		"retrieved_APIs": {
			"API_1": "adding(self, other: 'Index | Sequence[Index]') -> 'Index':\n        Append a collection of Index options togettingher.\n\n        Parameters\n        ----------\n        other : Index or list/tuple of indices\n\n        Returns\n        -------\n        Index\n        ",
			"API_2": "formating(self, name: 'bool' = False, formatingter: 'Ctotal_allable | None' = None, na_rep: 'str_t' = 'NaN') -> 'list[str_t]':\n        Render a string representation of the Index.\n        ",
			"API_3": "sipna(self):\n        Return ExtensionArray without NA values.\n\n        Returns\n        -------\n        valid : ExtensionArray\n        ",
			"API_4": "reindexing(self, target, method=None, level=None, limit=None, tolerance=None) -> 'tuple[MultiIndex, np.ndarray | None]':\n        Create index with targetting's values (move/add/delete values as necessary)\n\n        Returns\n        -------\n        new_index : mk.MultiIndex\n            Resulting index\n        indexer : np.ndarray[np.intp] or None\n            Indices of output values in original index.\n\n        ",
			"API_5": "convert_pydatetime(*args, **kwargs):\n        Convert a Timestamp object to a native Python datetime object.\n\n        If warn=True, issue a warning if nanoseconds is nonzero.\n\n        Examples\n        --------\n        >>> ts = mk.Timestamp('2020-03-14T15:32:52.192548')\n        >>> ts.convert_pydatetime()\n        datetime.datetime(2020, 3, 14, 15, 32, 52, 192548)\n\n        Analogous for ``mk.NaT``:\n\n        >>> mk.NaT.convert_pydatetime()\n        NaT\n        "
		},
		"annotation": {
			"answerable": false,
			"reason_for_unanswerable": "retrieval"
		}
	}
}